(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require("vue")) : typeof define === "function" && define.amd ? define(["vue"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.VueColorPicker = factory(global.Vue));
})(this, function(vue) {
  "use strict";
  const TO_DEGREES = 180 / Math.PI;
  const normalizeAngle = (angle) => {
    const mod = angle % 360;
    return mod < 0 ? 360 + mod : mod;
  };
  const getRotationFromCoords = ({
    x,
    y
  }, rect) => {
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    return Math.atan2(y - cy, x - cx) * TO_DEGREES;
  };
  const noop = () => {
  };
  class Rotator {
    constructor(element, options) {
      this.active = false;
      this.element = element;
      this.element.style.willChange = "transform";
      this.initOptions(options);
      this.updateCSS();
      this.bindHandlers();
      this.addListeners();
    }
    get angle() {
      return this._angle;
    }
    set angle(value) {
      if (this._angle !== value) {
        this._angle = normalizeAngle(value);
        this.updateCSS();
      }
    }
    initOptions(options) {
      options = options || {};
      this.onRotate = options.onRotate || noop;
      this.onDragStart = options.onDragStart || noop;
      this.onDragStop = options.onDragStop || noop;
      this._angle = options.angle || 0;
    }
    bindHandlers() {
      this.onRotationStart = this.onRotationStart.bind(this);
      this.onRotated = this.onRotated.bind(this);
      this.onRotationStop = this.onRotationStop.bind(this);
    }
    addListeners() {
      this.element.addEventListener("touchstart", this.onRotationStart, {
        passive: true
      });
      document.addEventListener("touchmove", this.onRotated, {
        passive: false
      });
      document.addEventListener("touchend", this.onRotationStop, {
        passive: true
      });
      document.addEventListener("touchcancel", this.onRotationStop, {
        passive: true
      });
      this.element.addEventListener("mousedown", this.onRotationStart, {
        passive: true
      });
      document.addEventListener("mousemove", this.onRotated, {
        passive: false
      });
      document.addEventListener("mouseup", this.onRotationStop, {
        passive: true
      });
      document.addEventListener("mouseleave", this.onRotationStop, {
        passive: false
      });
    }
    removeListeners() {
      this.element.removeEventListener("touchstart", this.onRotationStart);
      document.removeEventListener("touchmove", this.onRotated);
      document.removeEventListener("touchend", this.onRotationStop);
      document.removeEventListener("touchcancel", this.onRotationStop);
      this.element.removeEventListener("mousedown", this.onRotationStart);
      document.removeEventListener("mousemove", this.onRotated);
      document.removeEventListener("mouseup", this.onRotationStop);
      document.removeEventListener("mouseleave", this.onRotationStop);
    }
    destroy() {
      this.onRotationStop();
      this.removeListeners();
    }
    onRotationStart(event) {
      if (event.type === "touchstart" || event.button === 0) {
        this.active = true;
        this.onDragStart(event);
        this.setAngleFromEvent(event);
      }
    }
    onRotationStop() {
      if (this.active) {
        this.active = false;
        this.onDragStop();
      }
      this.active = false;
    }
    onRotated(event) {
      if (this.active) {
        event.preventDefault();
        this.setAngleFromEvent(event);
      }
    }
    setAngleFromEvent(event) {
      const ev = event.targetTouches ? event.targetTouches[0] : event;
      const newAngle = getRotationFromCoords({
        x: ev.clientX,
        y: ev.clientY
      }, this.element.getBoundingClientRect());
      this._angle = normalizeAngle(newAngle + 90);
      this.updateCSS();
      this.onRotate(this._angle);
    }
    updateCSS() {
      this.element.style.transform = "rotate(" + this._angle + "deg)";
    }
  }
  var ColorPicker_vue_vue_type_style_index_0_lang = "\n.rcp,\n    .rcp div,\n    .rcp button {\n        -webkit-touch-callout: none;\n        -webkit-tap-highlight-color: transparent;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        user-select: none;\n        box-sizing: border-box;\n}\n.rcp {\n        display: block;\n        overflow: hidden;\n        width: 280px;\n        height: 280px;\n        position: relative;\n        transform: scale(1.001);\n        transition: transform 0.15s cubic-bezier(0.68, 0, 0.47, 2);\n}\n.rcp:focus {\n        outline: 0;\n}\n.rcp:hover .rcp__knob {\n        box-shadow: 0 0 20px rgba(0, 0, 0, 0.19), 0 0 10px rgba(0, 0, 0, 0.24);\n}\n.rcp.dragging {\n        transform: scale(1.04);\n}\n.rcp.disabled {\n        cursor: not-allowed;\n        transform: scale(0.96);\n}\n.rcp.dragging .rcp__rotator {\n        z-index: 1;\n}\n.rcp__palette {\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        width: 100%;\n        height: 100%;\n        background-size: 100% 100%;\n        background-image: conic-gradient(red, yellow, lime, aqua, blue, magenta, red);\n        -webkit-mask-image: radial-gradient(circle at 50% 50%, transparent 53.5%, black 54%);\n        mask-image: radial-gradient(circle at 50% 50%, transparent 53.5%, black 54%);\n        border-radius: 50%;\n        overflow: hidden;\n        will-change: transform, opacity;\n        transition: transform 0.5s cubic-bezier(0.35, 0, 0.25, 1), opacity 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n}\n.rcp__palette.in {\n        transform: scale(1);\n        opacity: 1;\n}\n.rcp__palette.out {\n        transform: scale(0);\n        opacity: 0;\n}\n.disabled .rcp__palette {\n        filter: contrast(0.25);\n}\n.rcp__rotator {\n        width: 100%;\n        height: 100%;\n        position: absolute;\n        transform: rotate(var(--rcp-initial-angle));\n}\n.rcp__knob {\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.12), 0 0 5px rgba(0, 0, 0, 0.16);\n        border-radius: 50%;\n        position: absolute;\n        width: 7%;\n        height: 7%;\n        top: 2.5%;\n        left: 46.5%;\n        background-color: #fff;\n        transition: transform 0.4s cubic-bezier(0.35, 0, 0.25, 1);\n        outline: 0;\n        border-style: none;\n}\n.rcp__knob.in {\n        transform: scale(1);\n}\n.rcp__knob.out {\n        transform: scale(0);\n}\n.disabled .rcp__knob {\n        box-shadow: none;\n        pointer-events: none;\n}\n.rcp__well {\n        position: absolute;\n        width: 25%;\n        height: 25%;\n        top: 37.5%;\n        left: 37.5%;\n        padding: 0;\n        margin: 0;\n        border-radius: 50%;\n        background-color: #ff0000;\n        outline: 0;\n        cursor: pointer;\n        overflow: visible;\n        border: 6px solid #fff;\n        box-shadow: 0 0 0 1px #b2b2b2;\n}\n.rcp__well::-moz-focus-inner {\n        border: 0;\n}\n.rcp__well:hover {\n        box-shadow: 0 0 1px 1px #333;\n}\n.rcp__well:focus {\n        box-shadow: 0 0 1px 2px #b2b2b2;\n}\n.rcp__well.pressed {\n        animation: rcp-beat 0.4s cubic-bezier(0.35, 0, 0.25, 1) forwards;\n}\n.disabled .rcp__well {\n        background-color: #bfbfbf !important;\n        pointer-events: none;\n}\n.rcp__ripple {\n        width: 20%;\n        height: 20%;\n        border-radius: 50%;\n        border: #ff0000 solid 8px;\n        opacity: 0;\n        position: absolute;\n        top: 40%;\n        left: 40%;\n        z-index: -1;\n}\n.rcp__ripple.rippling {\n        z-index: 0;\n        animation: rcp-ripple 0.5s cubic-bezier(0.35, 0, 0.25, 1) forwards;\n}\n@keyframes rcp-ripple {\n0% {\n            transform: scale(1);\n            opacity: 0.3;\n}\n50% {\n            opacity: 0.1;\n}\n100% {\n            opacity: 0;\n            border-width: 0;\n            transform: scale(3.8);\n}\n}\n@keyframes rcp-beat {\n0% {\n            transform: scale(1);\n}\n25% {\n            transform: scale(0.8);\n}\n50% {\n            transform: scale(1);\n}\n100% {\n            transform: scale(1);\n}\n}\n";
  const colors = ["red", "yellow", "green", "cyan", "blue", "magenta", "red"];
  const keys = {
    ArrowUp: (oldAngle, step) => oldAngle + step,
    ArrowRight: (oldAngle, step) => oldAngle + step,
    ArrowDown: (oldAngle, step) => oldAngle - step,
    ArrowLeft: (oldAngle, step) => oldAngle - step,
    PageUp: (oldAngle, step) => oldAngle + step * 10,
    PageDown: (oldAngle, step) => oldAngle - step * 10,
    Home: () => 0,
    End: () => 359
  };
  const _sfc_main = {
    name: "ColorPicker",
    emits: ["select", "input", "change"],
    props: {
      hue: {
        default: 0
      },
      saturation: {
        default: 100
      },
      luminosity: {
        default: 50
      },
      alpha: {
        default: 1
      },
      step: {
        default: 1
      },
      mouseScroll: {
        default: false
      },
      variant: {
        default: "collapsible"
      },
      disabled: {
        default: false
      },
      initiallyCollapsed: {
        default: false
      },
      ariaLabel: {
        default: "color picker"
      },
      ariaRoledescription: {
        default: "radial slider"
      },
      ariaValuetext: {
        default: ""
      },
      ariaLabelColorWell: {
        default: "color well"
      }
    },
    setup(props, { emit }) {
      const el = vue.ref(null);
      const rotator = vue.ref(null);
      let rcp = null;
      const initialAngle = props.hue + "deg";
      const angle = vue.ref(props.hue);
      const isPaletteIn = vue.ref(!props.initiallyCollapsed);
      const isKnobIn = vue.ref(!props.initiallyCollapsed);
      const isPressed = vue.ref(false);
      const isRippling = vue.ref(false);
      const isDragging = vue.ref(false);
      const color = vue.computed(() => `hsla(${angle.value}, ${props.saturation}%, ${props.luminosity}%, ${props.alpha})`);
      const valuetext = vue.computed(() => {
        return colors[Math.round(angle.value / 60)];
      });
      vue.watch(() => props.hue, (value) => {
        angle.value = value;
        rcp.angle = value;
      });
      vue.onMounted(() => {
        rcp = new Rotator(rotator.value, {
          angle: angle.value,
          onRotate(hue) {
            angle.value = hue;
            emit("input", angle.value);
          },
          onDragStart() {
            isDragging.value = true;
          },
          onDragStop() {
            isDragging.value = false;
            emit("change", angle.value);
          }
        });
      });
      vue.onBeforeUnmount(() => {
        rcp.destroy();
        rcp = null;
      });
      const onKeyDown = (ev) => {
        if (props.disabled || isPressed.value || !isKnobIn.value || !(ev.key in keys))
          return;
        ev.preventDefault();
        rcp.angle = keys[ev.key](rcp.angle, props.step);
        angle.value = rcp.angle;
        emit("input", angle.value);
        emit("change", angle.value);
      };
      const onScroll = (ev) => {
        if (isPressed.value || !isKnobIn.value)
          return;
        ev.preventDefault();
        if (ev.deltaY > 0) {
          rcp.angle += props.step;
        } else {
          rcp.angle -= props.step;
        }
        angle.value = rcp.angle;
        emit("input", angle.value);
        emit("change", angle.value);
      };
      const selectColor = () => {
        isPressed.value = true;
        if (isPaletteIn.value && isKnobIn.value) {
          emit("select", angle.value);
          isRippling.value = true;
        } else {
          isPaletteIn.value = true;
        }
      };
      const togglePicker = () => {
        if (props.variant !== "persistent") {
          if (isKnobIn.value) {
            isKnobIn.value = false;
          } else {
            isKnobIn.value = true;
            isPaletteIn.value = true;
          }
        }
        isRippling.value = false;
        isPressed.value = false;
      };
      const hidePalette = () => {
        if (!isKnobIn.value) {
          isPaletteIn.value = false;
        }
      };
      return {
        rcp,
        el,
        rotator,
        initialAngle,
        angle,
        isPaletteIn,
        isKnobIn,
        isDragging,
        isRippling,
        isPressed,
        color,
        valuetext,
        onKeyDown,
        onScroll,
        selectColor,
        togglePicker,
        hidePalette
      };
    }
  };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createBlock("div", {
      ref: "el",
      role: "slider",
      "aria-roledescription": $props.ariaRoledescription,
      "aria-label": $props.ariaLabel,
      "aria-expanded": $setup.isPaletteIn,
      "aria-valuemin": "0",
      "aria-valuemax": "359",
      "aria-valuenow": $setup.angle,
      "aria-valuetext": $props.ariaValuetext || $setup.valuetext,
      "aria-disabled": $props.disabled,
      class: ["rcp", { dragging: $setup.isDragging, disabled: $props.disabled }],
      tabindex: $props.disabled ? -1 : 0,
      style: { "--rcp-initial-angle": $setup.initialAngle },
      onKeyup: _cache[4] || (_cache[4] = vue.withKeys((...args) => $setup.selectColor && $setup.selectColor(...args), ["enter"])),
      onKeydown: _cache[5] || (_cache[5] = (...args) => $setup.onKeyDown && $setup.onKeyDown(...args))
    }, [
      vue.createVNode("div", {
        class: ["rcp__palette", $setup.isPaletteIn ? "in" : "out"]
      }, null, 2),
      vue.createVNode("div", vue.mergeProps({
        class: "rcp__rotator",
        style: {
          "pointer-events": $props.disabled || $setup.isPressed || !$setup.isKnobIn ? "none" : null
        }
      }, vue.toHandlers($props.mouseScroll ? { wheel: $setup.onScroll } : {}), { ref: "rotator" }), [
        vue.createVNode("div", {
          class: ["rcp__knob", $setup.isKnobIn ? "in" : "out"],
          onTransitionend: _cache[1] || (_cache[1] = (...args) => $setup.hidePalette && $setup.hidePalette(...args))
        }, null, 34)
      ], 16),
      vue.createVNode("div", {
        class: ["rcp__ripple", { rippling: $setup.isRippling }],
        style: { borderColor: $setup.color }
      }, null, 6),
      vue.createVNode("button", {
        type: "button",
        class: ["rcp__well", { pressed: $setup.isPressed }],
        "aria-label": $props.ariaLabelColorWell,
        disabled: $props.disabled,
        tabindex: $props.disabled ? -1 : 0,
        style: { backgroundColor: $setup.color },
        onAnimationend: _cache[2] || (_cache[2] = (...args) => $setup.togglePicker && $setup.togglePicker(...args)),
        onClick: _cache[3] || (_cache[3] = (...args) => $setup.selectColor && $setup.selectColor(...args))
      }, null, 46, ["aria-label", "disabled", "tabindex"])
    ], 46, ["aria-roledescription", "aria-label", "aria-expanded", "aria-valuenow", "aria-valuetext", "aria-disabled", "tabindex"]);
  }
  _sfc_main.render = _sfc_render;
  _sfc_main.install = function(app) {
    app.component("ColorPicker", _sfc_main);
  };
  return _sfc_main;
});
